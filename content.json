[{"title":"","date":"2019-08-29T13:01:01.378Z","path":"2019/08/29/人脸识别（2）——训练/","text":"人脸识别（2）——训练标签（空格分隔）： 人脸识别 人脸模型的训练（需要读取人脸和人脸对应的标签）直接在数据库中读取显然是低效的，采用csv文件读取 ##1.提取csv ##2.训练 ###csv文件的生成：Python 脚本 生成at.txt ###CSV文件去读图像和标签:stringstream liness(line); //字符串的分割while (getline(file, line)) //从文本文件中读取一行字符 OpenCV 自带了三个人脸识别算法：Eigenfaces（特征脸），Fisherfaces 和局部二进制模式直方图 (LBPH) ###用到了opencv的Facerecognizer（特征脸）类 //创建一个PCA人脸分类器，命名为model，调用其中的成员函数train()来完成分类器的训练 Ptr model = EigenFaceRecognizer::create();model-&gt;train(images, labels);model-&gt;save(“MyFacePCAModel.xml”);//存储路径// Ptr model1 = FisherFaceRecognizer::create();model1-&gt;train(images, labels);model1-&gt;save(“MyFaceFisherModel.xml”); Ptr model2 = LBPHFaceRecognizer::create();model2-&gt;train(images, labels);model2-&gt;save(“MyFaceLBPHModel.xml”); int predictedLabel = model-&gt;predict(testSample);//加载分类器int predictedLabel1 = model1-&gt;predict(testSample);int predictedLabel2 = model2-&gt;predict(testSample)","updated":"2019-08-29T13:01:06.049Z","permalink":"feihu-jun.github.io/2019/08/29/人脸识别（2）——训练/","tags":[]},{"title":"","date":"2019-08-28T14:43:38.571Z","path":"2019/08/28/Linux编程/","text":"Linux编程——c/c++/gdb/make等标签（空格分隔）： linux Linux下C++开发 ##1.第一个c/c++程序 ###1.1 在vim/gedit中编写第一个HelloWorld程序 #include int main(){ std::cout &lt;&lt; “Hello Wolrd!” &lt;&lt; std::endl; return 0; } ###1.2 编译程序 g++ HelloWorld.cpp ./a.out ###1.3 第一个c程序 main.c #include int main(){ printf(“hello world!\\n”); return 0;} ###1.4执行gcc -E main.c -o main.i（预处理） gcc -S main.i -o main.s（编译） gcc -c main.s -o main.o（汇编） gcc main.o -o main （链接） ./main （执行） ##2. gcc/g++/gdb/makefile/make ###2.2 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序 后缀为.cpp的，两者都会认为是c++程序 ###2.3 gcc g++区别 对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）； 对于 .c和.cpp文件，g++则统一当做cpp文件编译； 使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL； gcc在编译C文件时，可使用的预定义宏是比较少的； gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏编译阶段，g++会调用gcc，对于c++代码，两者是等价的 因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接为了统一起见，编译/链接统统用g++(错觉：好像cpp程序只能用g++） ##3.gcc常用命令 3.1 gcc 命令语法： gcc 【options】 filename-list -ansi 以ANSI标准 -c 跳过连接步骤，编译成目标（.o)文件 -g 创建用于gdb的符号表和调试信息（debug） -S 跳过汇编和连接阶段，并保留编译产生的汇编代码（.a文件） -v 产生尽可能多的输出信息 -w 忽略警告信息 -o 将生成的可执行程序保存到指定文件中，而不是默认的a.out 3.2 ###make [选项] [目标] [宏定义] 常用选项： -d 显示调试信息 -f 文件 此选项告诉make使用指定文件作为依赖关系文件 -n 不执行makefile中的命令，只是显示输出这些命令 -s 执行但不显示任何信息 ###3.3 g++ 无 g++ test.cpp //默认输出a.out将test.cpp 预处理 、汇编、编译 、 链接形成可执行文件。 -o //-o用于指定输出文件名 -E 显示终端过程，不生成test.i文件 -S g++ -S test.i 将预处理输出的文件test.i汇编成test.s文件，效果与g++ -S test.i -o test.s相同。 -c g++ -c test. -O g++ -O1 test.c -o test 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长。 ###3.4 gdb gcc -c test.c -g(生成debug版) gcc test.c -o test 常用指令： gdb 可执行文件 : 表示对某个文件进行调试 b 函数名/行数 : 在某个函数名或行数前设置断点 run/r : 表示开始运行，如果是正在调试的程序的话，表示再次进行调试 n/next : 表示执行下一行语句list : 列出源码默认10行（当前位置的上下共10行）list 行号 : 列出行号上下共10行的源码list 函数名 : 列出函数名上下共10行的源码s/step : 表示单步执行，进入函数p /x 变量名 : 按16进制输出变量的值 /d : 按10进制 /o : 按八进制set var 变量名=值 : 设置变量的值bt(backtrace) : 查看各级函数调用及参数,简写btq/quit : 退出finish : 连续运行到当前函数返回为止，然后停下来等待命令continue/c : 跳转到下个断点，或者跳转到观察点ptype 变量名 : 可以查看变量的类型，简写为ptwatch 作用：一般用来观察某个变量/内存地址的状态(也可以是表达式）， 如可以监控该变量/内存值是否被程序读/写情况。 有三种方法： 1.watch expr（指定变量/内存地址/表达式） 一旦expr的值有变化时，将停住程序。 2.rwatch expr 当expr被读时，停住程序。 3.awatch expr 当expr被读或被写时，停住程序。 watch使用步骤： 1. 使用break在要观察的变量所在处设置断点； 2. 使用run执行，直到断点； 3. 使用watch设置观察点； 4. 使用continue观察设置的观察点是否有变化。 start : 开始执行程序，停在main函数第一行语句前面等待命令info watchpoints : 列出所有观察点 info breakpoints : 查看当前设置的所有断点d/delete [breakpoinsts num] [rang…] d/delete : 删除所有断点 d/delete num : 删除breakpoints为num的断点 d/delete num1-num2 : 删除breakpoints为num1-num2的断点enable num : 启用num号断点disable num : 关闭num号断点u/until : 结束当前循环 ###3.5 makefile（好资料，跟我一起写Makefile） 包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释 1.如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。 2.如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。 3.如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。","updated":"2019-08-29T12:37:54.282Z","permalink":"feihu-jun.github.io/2019/08/28/Linux编程/","tags":[]},{"title":"","date":"2019-08-28T13:35:34.792Z","path":"2019/08/28/Video for Linux two (Video4Linux2)/","text":"V4L2标签（空格分隔）：驱动 Video for Linux two (Video4Linux2) V4L2在includenuxideo.h文件下定义了一些重要的数据结构在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据本系统V4L2配置采用：在内核编译阶段配置（make menuconfig） ##1.工作流程 打开视频设备文件，进行视频采集的参数初始化，通过V4L2接口设置视频图像的采集窗口、采集的点阵大小和格式 申请若干视频采集的帧缓冲区，并将这些帧缓冲区从内核空间映射到用户空间，便于应用程序读取/处理视频数据 申请到的帧缓冲区在视频采集输入队列排队，并启动视频采集 驱动开始视频数据的采集，应用程序从视频采集输出队列取出帧缓冲区，处理完后，将帧缓冲区重新放入视频采集输入队列，循环往复采集连续的视频数据 停止视频采集。 在此输入正文 ##2.V4L2采集数据：内存映射(mmap)方式读取方式(read)方式 ##3.数据结构 v4l2_input 查询当前输入状态信息 视频输入及支持格式v4l2_crocap 设置捕捉能力参数 默认窗口大小,图像宽高v4l2_fmtdesc 用于设置格式相关参数 视频格式的名称v4l2_format 设置摄像头采集的参数视频制式、帧格式、采样区域的宽高v4l2_buffer 包含缓存相关信息缓存编号,缓存所占空间大小 ##4.关 键 函 数打开视频设备 fd=open(dev_name,O_RDWR|O_NONBLOCK)；dev_name 是指设备名称（devideo0）O_RDWR 表示以可读写的方式O_NONBLOCK 表示非阻塞模式 初始化操作用ioctl()函数","updated":"2019-08-28T14:53:36.142Z","permalink":"feihu-jun.github.io/2019/08/28/Video for Linux two (Video4Linux2)/","tags":[]},{"title":"","date":"2019-08-27T14:41:17.398Z","path":"2019/08/27/嵌入式系统平台的实现/","text":"人脸识别（嵌入式系统平台的实现）标签（空格分隔）： 人脸识别 ##嵌入式硬件系统：jz2440 开发板（ S3C2440 微处理器）[ ARM920T 内核，主频可达400MHz,内部总线结构为32/16-bit，外围控制模块接口丰富，比如摄像头接口，usb接口，LCD 接口等]摄像头采集模块，采集到的图像经过usb 与微处理器进行数据交互 ##嵌入式操作系统（Linux）：Linux ###1.引导加载程序（BootLoader）：本系统基于ARM920T内核体系uboot：支持烧写 yaffs2、JFFS2 根文件系统地址 0x00000000 ###2.Linux 内核：内核是操作系统的指挥官 ####2.1主要目录：include 包含了编译时所需要的大部分头文件kernel 包含了大部分 Linux 系统的内核函数mm 包含与内存管理相关的代码init 包含内核初始化的代码fs 文件系统相关的代码drivers 包含硬件设备驱动程序net 网络协议的实现代码 ####2.2内核的移植：sudo gedit Makefilemake menuconfigmake uImage命令生成 uImage 文件，DNW烧写进开发板中 ###3.根文件系统：数据管理的系统 ####3.1 作用；类型程序初始化；大量指令集；库文件JFFS2：奔溃数据不影响YAFFS2 ：减少开销，删减版Cramfs：只读性 ####3.2 主要目录/bin 可以看到一些可执行的文件，也就是可用的一些命令:如 cat、chgrp、chmod、cp、ls 等/dev 存放设备接口文件/etc 存放系统环境变量配置文件/home 存放普通用户的相关文件/lib 存放系统的库文件/sbin 存放系统命令，需要管理员权限才能使用的命令，如 shutdown、fdisk、init 等/tmp 存放临时文件/root 系统管理员目录/mnt 用于挂载的目录，通常是空的，当挂载到虚拟机上时会出现文件/proc 虚拟的文件系统/usr 存放共享目录 ####3.3 根文件移植busybox-1.7.0手动创建：/etc ，/dev等 ###4.设备驱动程序：（usb摄像头）驱动程序来操作这些硬件 ####4.1 作用初始化硬件设备传递内核数据到硬件设备，并从硬件设备读取数据从应用程序发送数据给设备文件，并返回应用程序请求的数据检测并处理硬件设备出现的错误 ####4.2 方式编译进内核，采用 insmod 方式加载 ####4.3驱动编写Nand Flash驱动模块 #####第一步： 修改arch/arm/plat-s3c24xx/common-smdk.c文件 static struct mtd_partition smdk_default_nand_part[ ] = {[0] = {.name = “Uboot”,.size = 0x00040000,.offset = 0x00000000,},[1] = {.name = “Kernel”,.offset = 0x00200000,.size = 0x00300000,},[2] = {.name = “filesystem”,.offset = 0x00500000,.size = MTDPART_SIZ_FULL,}}; #####第二步：修改 NAND 控制器参数，打开文件 arch/arm/plat-s3c24xx/common-smdk.c static struct s3c2410_platform_nand smdk_nand_info = {.tacls = 0,.twrph0 = 21,.twrph1 = 5,.nr_sets = ARRAY_SIZE(smdk_nand_sets),.sets = smdk_nand_sets,}; #####第三步：“make menuconfig”命令配置Device Drivers —&gt;&lt;&gt;Memory Technology Device（MTD）support —&gt;&lt;&gt; NAND Device Support —&gt;&lt;&gt; NAND Flash support for Samsung S3C SoCs—&gt;&lt;&gt; Samsung S3C NAND Hardware ECC ####USB 摄像头驱动模块第一步：Device Drivers —&gt;[] USB support —&gt;&lt;&gt;Support for Host-side USB[] USB device filesystem (DEPRECATED)[] USB device class-devices (DEPRECATED)&lt;&gt; OHCI HCD support&lt;&gt; USB Mass Storage support Device Drivers 里找到 Multimedia devices —&gt;&lt;&gt;Video For Linux[] Enable Video For Linux API 1 (DEPRECATED) (NEW)— Enable Video For Linux API 1 compatible Layer[] Video capture adapters (NEW) —&gt;[] Radio Adapters (NEW) —-&gt;&lt; &gt; DVB for Linux[*] DAB adapters 应用程序","updated":"2019-08-29T12:58:05.414Z","permalink":"feihu-jun.github.io/2019/08/27/嵌入式系统平台的实现/","tags":[]},{"title":"","date":"2019-02-23T08:31:27.652Z","path":"2019/02/23/CentOS7/","text":"CentOS7标签（空格分隔）： LINUX笔记 买了鸟叔的linux私房菜了，看到百来页,前面一些笔记就记在书上了。 安装了CentOS7 由于没有多余足够空间的启动盘，看书和博客终于成功安好了CentOS7（VMware下），并完成了网络配置终于可以上网了-0- vmnet0 桥接模式 vmnet1 host only（这个还不太懂 没用过） vmnet8 NAT模式 安装方式（默认/最小/全部/自定义） 磁盘分区文件类型： ext4/xfs注：swap不会用到目录树挂载 所以不需要挂载点 lvm：弹性改变文件大小而不改变内容 software RAID：软件仿真出磁盘阵列功能 vfat：同时被linux和windows识别的文件 分区过程（/ /boot swap /hoom ）： 1.先创建 / 目录：对应dev/sda1(和hda区别？)2.再创建 /boot 目录：会自动移动到磁盘最前面，磁盘分区变为/dev/hda1,起始柱面为13.创建swap目录：物理内存1.5-2倍之间4.创建/hoom目录：会自动将/dev/sda4变成扩展空间，把所有容量都个/dev/sda4,并将swap分配到/dev/sda5 其它的网络配置和其它配置就不写了，还是抓紧时间进入命令操作的联系吧 顺便记下几个linux操作1.vi命令 esc + ：+ w + q 保存并退出esc + ：+ q + ! 不保存强退 2.插入（insert）命令 i 和 l 附加插入命令 a和A su root/exit 进入/退出 root用户 后续写本子和书上了，有时间整理","updated":"2019-08-27T12:42:40.824Z","permalink":"feihu-jun.github.io/2019/02/23/CentOS7/","tags":[]},{"title":"","date":"2019-02-23T08:31:27.555Z","path":"2019/02/23/转载Markdown常用语法/","text":"转载Markdown常用语法 发现前面写的一些文章排版好丑，多学学这个变得好看清晰点。 标题 第一种是使用 # 表示标题，其中 # 号必须在行首，第二种是使用 === 或者 — 表示。 分割线 使用三个或以上的 - 或者 * 表示，且这一行只有符号，注意不要被识别为二级标题即可，例如中间或者前面可以加空格。 斜体和粗体 使用 和 * 分别表示斜体和粗体，删除线使用两个 ~ 表示 超链接和图片 链接和图片的写法类似，图片仅在超链接前多了一个 ! ，一般是 [文字描述] (链接) 无序列表 使用 -、+ 和 * 表示无序列表，前后留一行空白，可嵌套，例如 有序列表 使用 1. （点号后面有个空格）表示有序列表，可嵌套。 文字引用 使用 &gt; 表示，可以有多个 &gt;，表示层级更深，例如 行内代码块 其实上面已经用过很多次了，即使用 ` 表示，例如 扩展：很多字符是需要转义，使用反斜杠 \\ 进行转义 代码块 使用四个空格缩进表示代码块，一些 IDE 支持行数提示和着色，一般使用三个 ` 表示，例如 表格 直接看例子吧，第二行的 —: 表示了对齐方式，默认左对齐，还有 右对齐 和 居中 商品 数量 单价 苹果 10 \\$1 电脑 1 \\$1000 流程图 主要的语法为 name=&gt;type: describe，其中 type 主要有以下几种：1.开始和结束：start end2.输入输出：inputoutput3.操作：operation4.条件：condition5.子程序：subroutine 更多语法参考：流程图语法参考 数学公式 使用 $ 表示，其中一个 $ 表示在行内，两个 $ 表示独占一行。 eg : $\\sum_{i=1}^n a_i=0$ 支持 LaTeX 编辑显示支持，访问 MathJax 参考更多使用方法。 推荐一个常用的数学公式在线编译网站：https://www.codecogs.com/latex/eqneditor.php 13.支持 HTML 标签 例如想要段落的缩进，可以如下： &nbsp;&nbsp;不断行的空白格&nbsp;或&#160;&ensp;&ensp;半方大的空白&ensp;或&#8194;&emsp;&emsp;全方大的空白&emsp;或&#8195; 点我跳转的功能这里演示不了，写法如下： &lt;h6 id=&apos;anchor&apos;&gt;我是一个锚点&lt;/h6&gt; [点我跳转](#anchor) 作者：阿飞来源：CSDN原文：https://blog.csdn.net/afei/article/details/80717153版权声明：本文为博主原创文章，转载请附上博文链接！","updated":"2019-02-23T08:38:26.726Z","permalink":"feihu-jun.github.io/2019/02/23/转载Markdown常用语法/","tags":[]},{"title":"","date":"2019-02-21T13:49:35.828Z","path":"2019/02/21/c第一章笔记 /","text":"笔记标签（空格分隔）： c primer plus 笔记 1.几个标准&nbsp;&nbsp;ANSI/ISO C标准&nbsp;&nbsp;c99标准&nbsp;&nbsp;c11标准 2.几个比较重要的流程图 初学者别忽视第一二步，先规划，用笔纸记录程序目标和设计框架。 2.编译器和链接器编译器&nbsp;&nbsp;负责把c代码翻译成特点的机器语言 &nbsp;&nbsp;将源码与c库代码合并成最终代码 &nbsp;&nbsp;检查c程序，报错 链接器&nbsp;&nbsp;源码和c库的链接由链接器程序完成 &nbsp;&nbsp;大多数系统中编译器运行连接器 3.几个具体系统*UNIX系统&nbsp;&nbsp;注：UNIX区分大小写。 test.C 为无效文件 应为test.C&nbsp;&nbsp;原始文件有多个源代码文件，保留目标代码文件（.obj） &nbsp;&nbsp;编译：GNU（又名GCC）编译器和LLVM项目 *LINUX系统（可访问windows文档）&nbsp;&nbsp;GCC基本语法：gcc [options] [filenames] //参数 文件名 &nbsp;&nbsp;编译：使用GNU提供的GCC公共域c编译器 *pc的命令行编译器&nbsp;&nbsp;&nbsp; Cygwin和MinGW &nbsp;&nbsp;“字处理文件（包含其它信息：字体，格式）”和“文本文件”（源代码文件） *Windows（不可访问linux文档）&nbsp;&nbsp;IDE&nbsp;&nbsp;TIP: 程序执行完，执行窗口立即消失的解决方法在 return（）这行代码之前加getchar（）需要击键等待时，用两个getchar（）","updated":"2019-08-27T12:41:38.305Z","permalink":"feihu-jun.github.io/2019/02/21/c第一章笔记 /","tags":[]},{"title":"","date":"2018-01-13T13:31:38.889Z","path":"2018/01/13/时光小记二/","text":"时光小记二标签（空格分隔）： 小记 —2018年1月13日&nbsp;&nbsp;&nbsp;&nbsp;辗转已经18年，日子还是这样不是期待的但是还凑合的过着，生活没有太大的改变，而与之欲来的欲望却越发的强烈。&nbsp;&nbsp;&nbsp;&nbsp;太久没下笔，也是窘迫起来，只好装模作样的列三个新年目标。1.健身达到理想状态 隔天五公里变速跑加两个专项训练（这个目前基本达到，体重稳定在63kg了） 2.说服家里来年养只猫，不管是橘猫还是黑猫英短我都愿意，重要的是说服家里。 3.努力学习","updated":"2019-08-27T12:40:31.208Z","permalink":"feihu-jun.github.io/2018/01/13/时光小记二/","tags":[]},{"title":"","date":"2017-04-10T08:04:34.867Z","path":"2017/04/10/我回来了/","text":"我回来了标签（空格分隔）： 小记 还是只有我最关心你了 哈哈","updated":"2017-04-10T08:04:51.239Z","permalink":"feihu-jun.github.io/2017/04/10/我回来了/","tags":[]},{"title":"","date":"2017-03-06T02:05:19.184Z","path":"2017/03/06/起司猫/","text":"起司猫标签（空格分隔）： 测试1","updated":"2019-01-21T11:09:45.649Z","permalink":"feihu-jun.github.io/2017/03/06/起司猫/","tags":[]},{"title":"hi,look here","date":"2017-03-01T06:38:10.000Z","path":"2017/03/01/hi-visitor/","text":"欢迎来到飞狐君的世界，评论功能，相册功能，打赏功能等（划重点）陆续开发中。3-4号，开发了评论功能和百度统计，以及打赏二维码。3-5号，添加相册失败，网页崩盘两次- -，买了个域名4块，www.feihu-jun.top3-6号，弄好了多说评论，美化了下，顺便做了个留言板和来访显示。找到图窗七牛云。 弄了两个夜晚终于有点雏形了，撒花。","updated":"2017-03-06T15:05:38.869Z","permalink":"feihu-jun.github.io/2017/03/01/hi-visitor/","tags":[]}]